/* ********************************************************************
//  Class: MTuple
//  Inline methods for class MTuple
//  -------------------------------------------------------------------
//  Project: Repairing and texturing of VR models
//  (C) Copyright Fachhochschule Wedel, Germany 2003
//  -------------------------------------------------------------------
//  $Revision: 1.2 $
//  $Date: 2006-03-27 09:02:56 $
// ******************************************************************** */

template<class Scalar> INLINE Scalar &
CxxUtils::MTuple<Scalar>::at (int pos)
{
  return this->m_coord[pos];
}

template<class Scalar> INLINE CxxUtils::MTuple<Scalar> &
CxxUtils::MTuple<Scalar>::operator+= (CxxUtils::MTuple<Scalar> & v)
{
  addToMe (v);
  return *this;
}

template<class Scalar> INLINE CxxUtils::MTuple<Scalar> &
CxxUtils::MTuple<Scalar>::operator-= (CxxUtils::MTuple<Scalar> & v)
{
  subFromMe (v);
  return *this;
}

template<class Scalar> INLINE CxxUtils::MTuple<Scalar> &
CxxUtils::MTuple<Scalar>::operator*= (const Scalar s)
{
  multMeBy (s);
  return *this;
}

template<class Scalar> INLINE CxxUtils::MTuple<Scalar> &
CxxUtils::MTuple<Scalar>::operator/= (const Scalar s)
{
  divMeBy (s);
  return *this;
}

template<class Scalar> INLINE CxxUtils::MTuple<Scalar> 
CxxUtils::MTuple<Scalar>::mul (const CxxUtils::MTuple<Scalar> & v) const 
{
  return MTuple<Scalar> (this->multiply (v));
}

////////////////////////////////////////////////////////////////////////
// BINARY ASSIGNMENT OPERATORS
// NOTE: operators of type `Scalar operator Tuple` are not
// implemented due to template constraints
////////////////////////////////////////////////////////////////////////

// Returns the sum of *this and tuple t
template<class Scalar> INLINE CxxUtils::AbstractTuple<Scalar>
CxxUtils::AbstractTuple<Scalar>::add (const CxxUtils::AbstractTuple<Scalar> &t) const
{
  return AbstractTuple<Scalar> (*this, '+', t);
}

// Returns the sum of *this and Scalar s
template<class Scalar> INLINE CxxUtils::AbstractTuple<Scalar>
CxxUtils::AbstractTuple<Scalar>::add (const Scalar s) const
{
  return AbstractTuple<Scalar> (*this, '+', s);
}

// Returns the difference of *this and tuple t
template<class Scalar> INLINE CxxUtils::AbstractTuple<Scalar>
CxxUtils::AbstractTuple<Scalar>::subtract (const CxxUtils::AbstractTuple<Scalar> &t) const
{
  return AbstractTuple<Scalar> (*this, '-', t);
}

// Returns the difference of *this and Scalar s
template<class Scalar> INLINE CxxUtils::AbstractTuple<Scalar>
CxxUtils::AbstractTuple<Scalar>::subtract (const Scalar s) const
{
  return AbstractTuple<Scalar> (*this, '-', s);
}

// Returns the componentwise product of *this and tuple t
template<class Scalar> INLINE CxxUtils::AbstractTuple<Scalar>
CxxUtils::AbstractTuple<Scalar>::multiply (const CxxUtils::AbstractTuple<Scalar> &t) const
{
  return AbstractTuple<Scalar> (*this, '*', t);
}

// Returns the componentwise product of *this and Scalar s
template<class Scalar> INLINE CxxUtils::AbstractTuple<Scalar>
CxxUtils::AbstractTuple<Scalar>::multiply (const Scalar s) const
{
  return AbstractTuple<Scalar> (*this, '*', s);
}

// Returns the componentwise division of *this by tuple t
// NOTE: The components of t MUST be != zero!
template<class Scalar> INLINE CxxUtils::AbstractTuple<Scalar>
CxxUtils::AbstractTuple<Scalar>::divide (const CxxUtils::AbstractTuple<Scalar> &t) const
{
  return AbstractTuple<Scalar> (*this, '/', t);
}

// Returns the componentwise division of *this by s
// NOTE: s MUST be != zero!
template<class Scalar> INLINE CxxUtils::AbstractTuple<Scalar>
CxxUtils::AbstractTuple<Scalar>::divide (const Scalar s) const
{
  return AbstractTuple<Scalar> (*this, '/', s);
}
